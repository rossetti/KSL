/*
 *     The KSL provides a discrete-event simulation library for the Kotlin programming language.
 *     Copyright (C) 2023  Manuel D. Rossetti, rossetti@uark.edu
 *
 *     This program is free software: you can redistribute it and/or modify
 *     it under the terms of the GNU General Public License as published by
 *     the Free Software Foundation, either version 3 of the License, or
 *     (at your option) any later version.
 *
 *     This program is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *     GNU General Public License for more details.
 *
 *     You should have received a copy of the GNU General Public License
 *     along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package ksl.modeling.elements

import ksl.modeling.variable.RandomVariable
import ksl.simulation.ModelElement
import ksl.utilities.random.rvariable.RVariableIfc


open class EventGenerator protected constructor(
    parent: ModelElement,
    name: String? = null,
    protected val baseEventGenerator: BaseEventGenerator
) : ModelElement(parent, name), EventGeneratorIfc by baseEventGenerator,
    EventGeneratorInitializationCIfc by baseEventGenerator, EventGeneratorRVIfc {

    // The random variables handle the setting of their initial sources.
    // The random variables also handle the resetting of the random sources to initial values prior
    // to the running of replications.

    /**
     * This class allows for the periodic generation of events similar to that
     * achieved by "Create" modules in simulation languages. This class works in
     * conjunction with the GeneratorActionIfc which is used to listen and
     * react to the events that are generated by this class.
     *
     * Of particular note is the use of initial parameters:
     *
     * initial time of first event
     * initial time between events
     * initial maximum number of events (default = Long.MAX_VALUE)
     * initial ending time (default = Double.POSITIVE_INFINITY)
     *
     * These parameters control the initial state of the generator at the start
     * of each replication. The generator is re-initialized to these values at
     * the start of each replication. There are also parameters for each of these
     * that can be changed during a replication. The effect of that change
     * is only within the current replication.
     *
     * @param parent the parent model element
     * @param generateAction The action supplies the generation logic for reacting to the generated event.
     * @param timeUntilFirstRV A RandomIfc object that supplies the time until the first event.
     * @param timeBtwEventsRV A RandomIfc object that supplies the time between
     * events. Must not be a RandomIfc that always returns 0.0, if the maximum
     * number of generations is infinite (Long.MAX_VALUE)
     * @param maxNumberOfEvents A long that supplies the maximum number of events to
     * generate. Each time an event is to be scheduled the maximum number of
     * events is checked. If the maximum has been reached, then the generator is
     * turned off. The default is Long.MAX_VALUE. This parameter cannot be
     * Long.MAX_VALUE when the time until next always returns a value of 0.0
     * @param timeOfTheLastEvent A double that supplies a time to stop generating
     * events. When the generator is created, this variable is used to set the
     * ending time of the generator. Each time an event is to be scheduled the
     * ending time is checked. If the time of the next event is past this time,
     * then the generator is turned off and the event won't be scheduled. The
     * default is Double.POSITIVE_INFINITY.
     * @param name the name of the generator
     */
    constructor(
        parent: ModelElement,
        generateAction: GeneratorActionIfc? = null,
        timeUntilFirstRV: RVariableIfc,
        timeBtwEventsRV: RVariableIfc,
        maxNumberOfEvents: Long = Long.MAX_VALUE,
        timeOfTheLastEvent: Double = Double.POSITIVE_INFINITY,
        name: String? = null
    ) : this(
        parent, name, BaseEventGenerator(parent, generateAction, timeUntilFirstRV,
            timeBtwEventsRV, maxNumberOfEvents, timeOfTheLastEvent
        )
    )

    /**
     * This class allows for the periodic generation of events similar to that
     * achieved by "Create" modules in simulation languages. This class works in
     * conjunction with the GeneratorActionIfc which is used to listen and
     * react to the events that are generated by this class.
     *
     * @param parent the parent model element
     * @param generateAction The action supplies the generation logic for reacting to the generated event.
     * @param arrivalsRV A RVariableIfc object that supplies both the time until the first and
     * the time between events random variables.
     * @param maxNumberOfEvents A long that supplies the maximum number of events to
     * generate. Each time an event is to be scheduled the maximum number of
     * events is checked. If the maximum has been reached, then the generator is
     * turned off. The default is Long.MAX_VALUE. This parameter cannot be
     * Long.MAX_VALUE when the time until next always returns a value of 0.0
     * @param timeOfTheLastEvent A double that supplies a time to stop generating
     * events. When the generator is created, this variable is used to set the
     * ending time of the generator. Each time an event is to be scheduled the
     * ending time is checked. If the time of the next event is past this time,
     * then the generator is turned off and the event won't be scheduled. The
     * default is Double.POSITIVE_INFINITY.
     * @param name the name of the generator
     */
    constructor(
        parent: ModelElement,
        generateAction: GeneratorActionIfc? = null,
        arrivalsRV: RVariableIfc,
        maxNumberOfEvents: Long = Long.MAX_VALUE,
        timeOfTheLastEvent: Double = Double.POSITIVE_INFINITY,
        name: String? = null
    ) : this(
        parent, name, BaseEventGenerator(parent, generateAction, arrivalsRV,
            arrivalsRV, maxNumberOfEvents, timeOfTheLastEvent
        )
    )

    /**
     * A RandomVariable that uses the time until first random source
     */
    private val myTimeUntilFirstEventRV: RandomVariable =
        RandomVariable(this, baseEventGenerator.timeUntilFirstEvent as RVariableIfc, "${this.name}:TimeUntilFirstEventRV")

    override var timeUntilFirstEvent: RVariableIfc
        get() = myTimeUntilFirstEventRV.initialRandomSource
        set(value) {
            myTimeUntilFirstEventRV.initialRandomSource = value
            baseEventGenerator.timeUntilFirstEvent = value
        }

    override fun setTimeBetweenEvents(timeBtwEvents: RVariableIfc, maxNumEvents: Long) {
        baseEventGenerator.setTimeBetweenEvents(timeBtwEvents, maxNumEvents)
        myTimeBtwEventsRV.randomSource = timeBtwEvents
    }

    /**
     * A random variable for the time between events
     */
    private val myTimeBtwEventsRV: RandomVariable =
        RandomVariable(this, baseEventGenerator.timeBetweenEvents as RVariableIfc, "${this.name}:TimeBtwEventsRV")

    /**
     * The time between events for the current replication
     */
    override var timeBetweenEvents: RVariableIfc
        get() = myTimeBtwEventsRV.randomSource
        set(timeUntilNext) {
            setTimeBetweenEvents(timeUntilNext, baseEventGenerator.maximumNumberOfEvents)
        }

    override var initialTimeBtwEvents: RVariableIfc
        get() = myTimeBtwEventsRV.initialRandomSource
        set(value) {
            setInitialTimeBetweenEventsAndMaxNumEvents(value, baseEventGenerator.initialMaximumNumberOfEvents)
        }

    override fun setInitialTimeBetweenEventsAndMaxNumEvents(
        initialTimeBtwEvents: RVariableIfc,
        initialMaxNumEvents: Long
    ) {
        baseEventGenerator.setInitialTimeBetweenEventsAndMaxNumEvents(initialTimeBtwEvents, initialMaxNumEvents)
        myTimeBtwEventsRV.initialRandomSource = initialTimeBtwEvents
    }

    override fun setInitialEventTimeProcesses(eventTimeProcess: RVariableIfc) {
        baseEventGenerator.setInitialEventTimeProcesses(eventTimeProcess)
        timeUntilFirstEvent = eventTimeProcess
        initialTimeBtwEvents = eventTimeProcess
    }

}